{"pageProps":{"bundle":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"mdxJsReact\"),require(\"React\")):\"function\"==typeof define&&define.amd?define([\"mdxJsReact\",\"React\"],t):\"object\"==typeof exports?exports.MDXContent=t(require(\"mdxJsReact\"),require(\"React\")):e.MDXContent=t(e.mdxJsReact,e.React)}(this,((e,t)=>(()=>{\"use strict\";var n={24:e=>{e.exports=t},825:t=>{t.exports=e}},a={};function r(e){var t=a[e];if(void 0!==t)return t.exports;var i=a[e]={exports:{}};return n[e](i,i.exports,r),i.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})};var i={};return(()=>{r.r(i),r.d(i,{default:()=>a});var e=r(825),t=r(24),n=r.n(t);const a=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=Object.assign({},(0,e.useMDXComponents)(),t.components),r=a.wrapper;return r?n().createElement(r,t,n().createElement(i)):i();function i(){var a=Object.assign({p:\"p\",br:\"br\",h2:\"h2\",ul:\"ul\",li:\"li\",a:\"a\",h3:\"h3\",pre:\"pre\",code:\"code\",hr:\"hr\",ol:\"ol\",h4:\"h4\"},(0,e.useMDXComponents)(),t.components);return n().createElement(n().Fragment,null,n().createElement(a.p,null,\"The design goal of Gobld is to be stateless and as simple as possible.\"),\"\\n\",n().createElement(a.p,null,\"Webhook events are received via an API call from the Buildkite notification service and initially placed on an in-memory event queue.\",n().createElement(a.br),\"\\n\",\"An internal loop then pulls events from this queue and processes them by extracting relevant data and generating the required agent configuration for the selected provider before launching the requested instance.\"),\"\\n\",n().createElement(a.h2,{id:\"terminology\"},\"Terminology\"),\"\\n\",n().createElement(a.ul,null,\"\\n\",n().createElement(a.li,null,\"Agent: A Buildkite agent which is backed by an instance launched in one of the supported cloud providers.\"),\"\\n\",n().createElement(a.li,null,\"Agent Query Rules: A key-value list of tags specified as part of the Buildkite Job. See \",n().createElement(a.a,{href:\"https://buildkite.com/docs/agent/v3/cli-start#agent-targeting\"},\"agent targeting\"),\" for more information.\"),\"\\n\",n().createElement(a.li,null,\"Event Queue: An internal First-In First-Out (FIFO) queue used for storing and retrieving events that Gobld needs to action.\"),\"\\n\",n().createElement(a.li,null,\"Instance: A cloud instance, such as Kubernetes pod or a Google Cloud Engine VM.\"),\"\\n\",n().createElement(a.li,null,\"Provider config: This is configuration that is required to support launching and managing instances within the specified cloud provider.\"),\"\\n\",n().createElement(a.li,null,\"Provider defaults: This is configuration that is used as the default for any instance launched in this cloud provider. Any supplied values are merged with the default configuration before launching the instance.\"),\"\\n\",n().createElement(a.li,null,\"Webhook event: A webhook event is a notification that something has happened. The Buildkite notification service supports sending webhook events for a number of different events: \",n().createElement(a.a,{href:\"https://buildkite.com/docs/apis/webhooks\"},\"Buildkite Webhook docs\")),\"\\n\"),\"\\n\",n().createElement(a.h2,{id:\"how-it-works\"},\"How it works\"),\"\\n\",n().createElement(a.h3,{id:\"happy-flow\"},\"Happy flow\"),\"\\n\",n().createElement(a.p,null,\"This is a high level walkthrough of the happy flow of Gobld.\",n().createElement(a.br),\"\\n\",\"We are going to cover everything that happens from when a Buildkite pipeline run is triggered until the agent is destroyed.\"),\"\\n\",n().createElement(a.pre,null,n().createElement(a.code,{className:\"language-mermaid\",display:\"block\"},'sequenceDiagram\\nparticipant bk as Buildkite\\nparticipant api as Gobld API\\nparticipant eventQueue as Gobld Event Queue\\nparticipant creator as Gobld Creator\\nparticipant provider as Gobld Provider\\n\\npar Webhook handling\\n    bk->>api: Webhook event\\n    activate api\\n    api->>api: Validate and verify\\n    api->>api: Process \"job.scheduled\" event\\n    api->>eventQueue: Add event\\n    api--\\x3e>bk: Accept webhook event\\n    deactivate api\\nand Event processing\\n    loop\\n    creator->>eventQueue: Get Event from queue\\n    end\\n    eventQueue->>creator: Receive job event\\n    activate creator\\n    creator->>creator: Process Agent Query Rules\\n    creator->>creator: Generate configuration\\n    creator->>creator: Generate Agent name\\n    creator->>provider: Create instance\\n    activate provider\\n    provider->>provider: Watch instance status\\n    alt Instance creation succeeded\\n        provider->>creator: Instance running\\n    else Instance creation failed\\n        provider->>creator: Error returned\\n        deactivate provider\\n        creator->>bk: Build cancelled and annotated\\n    end\\n    deactivate creator\\nend\\n')),\"\\n\",n().createElement(a.h2,{id:\"each-loop-of-gobld-will-be-separated-with-a-line-break\"},\"Each loop of Gobld will be separated with a line break.\"),\"\\n\",n().createElement(a.ul,null,\"\\n\",n().createElement(a.li,null,\"Gobld receives a webhook event notification from Buildkite. This event is validated and verified.\"),\"\\n\",n().createElement(a.li,null,\"If the event passes the required checks, and is a \",n().createElement(a.code,{display:\"inline\"},\"job.scheduled\"),\" event then it's added in an in-memory Event Queue.\"),\"\\n\"),\"\\n\",n().createElement(a.hr),\"\\n\",n().createElement(a.ul,null,\"\\n\",n().createElement(a.li,null,\"Gobld checks to see if there are any events on the event queue.\"),\"\\n\",n().createElement(a.li,null,\"If an event is present, Gobld processes that event by extracting several elements from the event payload, such as the Job ID and Agent Query Rules in order to generate the correct agent configuration and cloud instance.\"),\"\\n\",n().createElement(a.li,null,\"Gobld processes the Agent Query Rules and generates an agent and instance configuration, and also selects the requested Cloud provider.\"),\"\\n\",n().createElement(a.li,null,\"Gobld generates a name value based on the configured \",n().createElement(a.code,{display:\"inline\"},\"prefix\"),\", selected Cloud provider and a generated timestamp.\"),\"\\n\",n().createElement(a.li,null,\"Gobld creates the instance in the relevant cloud provider.\"),\"\\n\",n().createElement(a.li,null,\"Gobld watches the instance to ensure that it launches within a configurable time period.\"),\"\\n\",n().createElement(a.li,null,\"If the instance fails to launch then the Buildkite build gets cancelled and annotated with further details of the failure.\"),\"\\n\"),\"\\n\",n().createElement(a.hr),\"\\n\",n().createElement(a.p,null,\"Separately Gobld is checking for cloud instances that are no longer running and deletes them to free up resources.\"),\"\\n\",n().createElement(a.h3,{id:\"event-queue\"},\"Event Queue\"),\"\\n\",n().createElement(a.p,null,'The current design of Gobld leverages an internal \"in-memory\" event queue to store webhook event notifications that have been received but not yet processed.'),\"\\n\",n().createElement(a.p,null,'The fact that the queue is \"in-memory\" means that it is quick and easy to utilise with no external dependencies.\\nHowever it does have the potential for event-loss if Gobld was to restart with events still in the queue.'),\"\\n\",n().createElement(a.p,null,\"In order to try and prevent this scenario, Gobld has been written to gracefully handle the \",n().createElement(a.code,{display:\"inline\"},\"SIGTERM\"),\" event that Kubernetes uses to signal a pod to terminate. \",n().createElement(a.a,{href:\"https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination\"},\"ref\"),n().createElement(a.br),\"\\n\",\"Once a \",n().createElement(a.code,{display:\"inline\"},\"SIGTERM\"),\" signal is received, Gobld will process the events it currently has in memory and then terminate.\"),\"\\n\",n().createElement(a.p,null,'In the future, this \"in-memory\" queue might be replaced with an external queue, such as GCP Pub/Sub.'),\"\\n\",n().createElement(a.h3,{id:\"what-happens-if-an-instance-fails-to-launch-or-connect\"},\"What happens if an instance fails to launch or connect?\"),\"\\n\",n().createElement(a.p,null,\"This is most likely to occur if an instance image fails to start or fails to connect to Buildkite.\",n().createElement(a.br),\"\\n\",\"In this scenario Gobld will \",n().createElement(a.a,{href:\"https://buildkite.com/docs/agent/v3/cli-annotate\"},\"annotate\"),\" the Buildkite build with the error that was returned when attempting to create or launch the agent.\",n().createElement(a.br),\"\\n\",\"Gobld will also cancel the build to prevent it hanging indefinitely.\"),\"\\n\",n().createElement(a.p,null,\"Human intervention is likely needed to identify the root cause of the issue and undertake any required corrective action.\"),\"\\n\",n().createElement(a.h3,{id:\"why-does-gobld-use-a-timestamp-in-the-name\"},\"Why does Gobld use a timestamp in the name?\"),\"\\n\",n().createElement(a.p,null,\"This was the simplest way to have a cross system way of generating a unique name that could also be used to determine the age of the instance.\\nThis is required so that Gobld can automatically prune any running instances that are older than the specified \",n().createElement(a.code,{display:\"inline\"},\"max-age\"),\" value.\"),\"\\n\",n().createElement(a.h3,{id:\"how-does-gobld-let-us-know-when-it-needs-help\"},\"How does Gobld let us know when it needs help?\"),\"\\n\",n().createElement(a.p,null,\"Gobld generates log messages which are processed by Llama. Alerts will be generated for the following situations:\\nTODO: Validate these alerts are still relevant/functional with Buildkite.\"),\"\\n\",n().createElement(a.ol,null,\"\\n\",n().createElement(a.li,null,\"Expiry alerts when a deployment stops sending events to Llama\"),\"\\n\",n().createElement(a.li,null,\"Alert for GCP errors (global alert shared between all controllers)\"),\"\\n\"),\"\\n\",n().createElement(a.p,null,\"You can read about how to deal with these alerts in the \",n().createElement(a.a,{href:\"./troubleshooting.md\"},\"troubleshooting documentation\")),\"\\n\",n().createElement(a.h3,{id:\"how-does-gobld-handle-multiple-providers\"},\"How does Gobld handle multiple providers?\"),\"\\n\",n().createElement(a.h4,{id:\"launching-instances\"},\"Launching instances\"),\"\\n\",n().createElement(a.p,null,\"Gobld supports specifying the required Cloud provider as part of the Agent query rules using the \",n().createElement(a.code,{display:\"inline\"},\"provider\"),\" tag.\",n().createElement(a.br),\"\\n\",\"If a provider is not specified, the Kubernetes (\",n().createElement(a.code,{display:\"inline\"},\"k8s\"),\") provider is used.\"),\"\\n\",n().createElement(a.h4,{id:\"handling-provider-failures\"},\"Handling provider failures\"),\"\\n\",n().createElement(a.p,null,\"Gobld follows the following rules for handling with different kind of failures. We want to make sure that Gobld can continue to function as much as possible even when a single provider is down.\"),\"\\n\",n().createElement(a.p,null,\"TODO: Validate gobld behaviour with Buildkite and provider failures.\"))}}})(),i})()));","frontmatter":{"id":"ciGobldDesign","slug":"/ci/gobld/design","title":"Design","summary":"Gobld design documentation","date":"2022-03-28T00:00:00.000Z","tags":["ci","ci/cd","developer tools","buildkite","gobld","engineering","platform"],"link":"https://github.com/elastic/ci/blob/main","linkPath":"docs/gobld/design.mdx"},"missionId":"krVideos"},"__N_SSG":true}