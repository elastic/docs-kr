{"pageProps":{"bundle":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"mdxJsReact\"),require(\"React\")):\"function\"==typeof define&&define.amd?define([\"mdxJsReact\",\"React\"],t):\"object\"==typeof exports?exports.MDXContent=t(require(\"mdxJsReact\"),require(\"React\")):e.MDXContent=t(e.mdxJsReact,e.React)}(this,((e,t)=>(()=>{\"use strict\";var n={24:e=>{e.exports=t},825:t=>{t.exports=e}},l={};function a(e){var t=l[e];if(void 0!==t)return t.exports;var i=l[e]={exports:{}};return n[e](i,i.exports,a),i.exports}a.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})};var i={};return(()=>{a.r(i),a.d(i,{default:()=>l});var e=a(825),t=a(24),n=a.n(t);const l=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=Object.assign({},(0,e.useMDXComponents)(),t.components),a=l.wrapper;return a?n().createElement(a,t,n().createElement(i)):i();function i(){var l=Object.assign({p:\"p\",h2:\"h2\",h3:\"h3\",pre:\"pre\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",a:\"a\",ul:\"ul\",li:\"li\",strong:\"strong\",br:\"br\"},(0,e.useMDXComponents)(),t.components);return n().createElement(n().Fragment,null,n().createElement(l.p,null,\"A provider enables Gobld to actually create CI workers somewhere. A provider is a generic way of abstracting the different provider specific configuration and actions needed to manage the machines.\"),\"\\n\",n().createElement(l.h2,{id:\"aws-provider\"},\"AWS Provider\"),\"\\n\",n().createElement(l.h3,{id:\"provider-configuration\"},\"Provider Configuration\"),\"\\n\",n().createElement(l.p,null,\"The default provider configuration defines fields that can't be changed on a per instance basis.\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{className:\"language-yaml\",display:\"block\"},\"providers:\\n  aws:\\n    config:\\n      instanceStartTimeout: 300        # Duration to wait for instance to enter a running state, in seconds\\n      keyPair: 'elastic-user'          # Default keyPair to use for launched instances\\n      project: 'elastic-prod'          # Project that instances will be launched in\\n      region: 'us-west-2'              # Default region\\n      securityGroups:                  # Default security groups that will be added to launched instances\\n        - 'allow-ssh-from-bastion'\\n      subnetPrefix: 'buildkite-agents' # Subnet prefix to use for launched instances\\n      vpc: 'buildkite-agents-vpc'      # VPC to use for launched instances\\n\")),\"\\n\",n().createElement(l.h3,{id:\"agent-default-configuration\"},\"Agent Default Configuration\"),\"\\n\",n().createElement(l.p,null,'The following configuration is used to specify the \"default\" AWS instance configuration.\\nAll of these fields can be overridden using Agent tags from the Buildkite pipeline.'),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{className:\"language-yaml\",display:\"block\"},\"providers:\\n  aws:\\n    defaults:\\n      diskName: '/dev/sda1'    # Default disk name for boot disk. Amazon Linux 2 expects '/dev/xvda'\\n      diskSizeGb: 30           # Default size in gigabytes of the disk\\n      diskType: 'gp3'          # Default disk type to launch instances with\\n      instanceType: 't2.micro' # Default instanceType for launched instances\\n      zones:                   # Default list of zones to deploy instances in. Can be overridden at the worker config level\\n        - 'us-west-2a'\\n        - 'us-west-2b'\\n        - 'us-west-2c'\\n\")),\"\\n\",n().createElement(l.h3,{id:\"supported-agent-configuration-tags\"},\"Supported agent configuration tags\"),\"\\n\",n().createElement(l.p,null,\"The following agent configuration tags are supported by the AWS provider:\"),\"\\n\",n().createElement(l.table,null,n().createElement(l.thead,null,n().createElement(l.tr,null,n().createElement(l.th,null,\"Tag\"),n().createElement(l.th,null,\"Description\"),n().createElement(l.th,null,\"Type\"),n().createElement(l.th,null,\"Default\"))),n().createElement(l.tbody,null,n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"diskName\")),n().createElement(l.td,null,\"The name of the boot disk for launched instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"diskSizeGb\")),n().createElement(l.td,null,\"The size of the Persistent Disk to allocate to this VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Integer\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"diskType\")),n().createElement(l.td,null,\"The type of Persistent Disk to allocate to this VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"image\")),n().createElement(l.td,null,\"AWS image to use for this instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"imagePrefix\")),n().createElement(l.td,null,\"AWS image prefix to search\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"instanceMaxAge\")),n().createElement(l.td,null,\"How long can this agent live for in minutes\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Integer\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"instanceType\")),n().createElement(l.td,null,\"AWS instance type to use for VM instance.\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"zones\")),n().createElement(l.td,null,\"List of AWS zones to consider when launching VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"List\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))))),\"\\n\",n().createElement(l.h3,{id:\"latest-amis---aka-image-families\"},\"Latest AMI's - aka Image Families\"),\"\\n\",n().createElement(l.p,null,'AWS doesn\\'t currently have the concept of Image Families in the same way that GCP does.\\nThat means in order to support the same workflow whereby instances automatically use the \"latest\" available AMI, we added the ',n().createElement(l.code,{display:\"inline\"},\"imagePrefix\"),\" field to the AWS worker config.\"),\"\\n\",n().createElement(l.p,null,\"If an \",n().createElement(l.code,{display:\"inline\"},\"imagePrefix\"),\" is supplied for a given worker configuration, \",n().createElement(l.code,{display:\"inline\"},\"gobld\"),\" will pull a list of AMI's that match the \",n().createElement(l.code,{display:\"inline\"},\"imagePrefix\"),\" value at the time of launching the instance, sort that list and use the most recently created AMI.\"),\"\\n\",n().createElement(l.p,null,\"If a specific AMI is required, use the \",n().createElement(l.code,{display:\"inline\"},\"image\"),\" config value.\"),\"\\n\",n().createElement(l.h2,{id:\"gcp-provider\"},\"GCP Provider\"),\"\\n\",n().createElement(l.h3,{id:\"provider-configuration-1\"},\"Provider Configuration\"),\"\\n\",n().createElement(l.p,null,\"The default provider configuration defines fields that can't be changed on a per instance basis.\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{className:\"language-yaml\",display:\"block\"},\"providers:\\n  gcp:\\n    config:\\n      instanceStartTimeout: 300      # Duration to wait for instance to enter a running state, in seconds\\n      network: 'buildkite-agents'    # Network for launched instances\\n      project: 'elastic-ci-prod'     # Project that instances will be launched in\\n      rateLimit: 50                  # Amount of requests per second to send to GCP\\n      region: 'us-central1'          # Default region\\n      subNetwork: 'buildkite-agents' # Sub-network for launched instances\\n\")),\"\\n\",n().createElement(l.h3,{id:\"agent-default-configuration-1\"},\"Agent Default Configuration\"),\"\\n\",n().createElement(l.p,null,'The following configuration is used to specify the \"default\" GCP instance configuration.\\nAll of these fields can be overridden using Agent tags from the Buildkite pipeline.'),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{className:\"language-yaml\",display:\"block\"},\"providers:\\n  gcp:\\n    defaults:\\n      assignExternalIP: true                    # Setting this to false will result in no external IP address being assigned to the launched instance, thereby using NAT instead\\n      diskSizeGb: 30                            # Default size in gigabytes of the disk\\n      diskType: 'pd-ssd'                        # Default disk type to launch instances with\\n      enableSecureBoot: false                   # Setting this to true will enable secure boot on the instance https://cloud.google.com/security/shielded-cloud/shielded-vm#secure-boot\\n      image: 'family/elastic-buildkite-agent-ubuntu-2004-lts'\\n      localSsds: 0                              # Default number of local SSDs / scratch disks https://cloud.google.com/compute/docs/disks/local-ssd\\n      localSsdInterface: 'NVME'                 # Default interface used for local SSDs, if any are specified. See below gotchas and more info\\n      machineType: 'n1-standard-4'              # Default machineType for launched instances\\n      minCpuPlatform: ''                        # Default minimum CPU platform for launched instances\\n      imageProject: 'elastic-images-prod'       # The default project where the instances images are located\\n      networkTags:                              # Default network tags that will be added to launched instances\\n        - 'buildkite-agent'\\n      preemptible: false                        # Setting this to true will launch a preemtible instance https://cloud.google.com/compute/docs/instances/preemptible\\n      schedulingNodeAffinity: {}                # Affinity labels for scheduling bring your own license workers on sole-tenant nodes\\n      serviceAccount: '<service account email>' # Default service account to assign to launched instance.\\n      zones:                                    # Default list of zones to deploy instances in. Can be overridden at the worker config level\\n        - 'us-central1-a'\\n        - 'us-central1-b'\\n        - 'us-central1-c'\\n        - 'us-central1-f'\\n\")),\"\\n\",n().createElement(l.h3,{id:\"supported-agent-configuration-tags-1\"},\"Supported agent configuration tags\"),\"\\n\",n().createElement(l.p,null,\"The following agent configuration tags are supported by the GCP provider:\"),\"\\n\",n().createElement(l.table,null,n().createElement(l.thead,null,n().createElement(l.tr,null,n().createElement(l.th,null,\"Tag\"),n().createElement(l.th,null,\"Description\"),n().createElement(l.th,null,\"Type\"),n().createElement(l.th,null,\"Default\"))),n().createElement(l.tbody,null,n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"diskSizeGb\")),n().createElement(l.td,null,\"The size of the Persistent Disk to allocate to this VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Integer\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"diskType\")),n().createElement(l.td,null,\"The type of Persistent Disk to allocate to this VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"enableSecureBoot\")),n().createElement(l.td,null,\"Should Secure boot be enabled on this instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Bool\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"image\")),n().createElement(l.td,null,\"GCP image or image family to use for this instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"imageProject\")),n().createElement(l.td,null,\"GCP project to read \",n().createElement(l.code,{display:\"inline\"},\"image\"),\" from\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"instanceMaxAge\")),n().createElement(l.td,null,\"How long can this agent live for in minutes\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Integer\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"localSsds\")),n().createElement(l.td,null,\"Number of local SSDs to allocate to this VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Integrer\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"localSsdInterface\")),n().createElement(l.td,null,\"SSD Interface to use for local SSD resources\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"machineType\")),n().createElement(l.td,null,\"GCP machine type to use for VM instance. Can either be pre-defined or custom. See below.\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"minCpuPlatform\")),n().createElement(l.td,null,\"Minimum CPU platform to requst for VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"preemptible\")),n().createElement(l.td,null,\"Should the launched VM instance be preemptible?\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Bool\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"useVault\")),n().createElement(l.td,null,\"Should a Vault token be generated and injected for this agent?\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Bool\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"zones\")),n().createElement(l.td,null,\"List of GCP zones to consider when launching VM instance\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"List\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))))),\"\\n\",n().createElement(l.h3,{id:\"custom-machine-types\"},\"Custom machine types\"),\"\\n\",n().createElement(l.p,null,\"In addition to the \",n().createElement(l.a,{href:\"https://cloud.google.com/compute/docs/machine-types#predefined_machine_types\"},\"pre-defined machine types\"),\" offered by GCP,\\nit is also possible to specify a \",n().createElement(l.a,{href:\"https://cloud.google.com/compute/docs/machine-types#custom_machine_types\"},\"custom machine type\"),\".\"),\"\\n\",n().createElement(l.p,null,\"There are a few \",n().createElement(l.a,{href:\"https://cloud.google.com/compute/docs/instances/creating-instance-with-custom-machine-type#specifications\"},\"limitations\"),\" when it\\ncomes to defining a custom machine type configuration. They are explained in more detail on the relevant Google Cloud docs page linked above.\"),\"\\n\",n().createElement(l.p,null,\"In order to specify a custom machine type for use with \",n().createElement(l.code,{display:\"inline\"},\"gobld\"),\", the \",n().createElement(l.code,{display:\"inline\"},\"machineType\"),\" config item should be formatted as follows:\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{display:\"block\"},\"machineType: 'custom-<CPUS>-<MEMORY>'\\n\")),\"\\n\",n().createElement(l.p,null,\"Where:\"),\"\\n\",n().createElement(l.ul,null,\"\\n\",n().createElement(l.li,null,n().createElement(l.code,{display:\"inline\"},\"<CPUS>\"),\" can either be 1; or a multiple of 2, upto the maximum permissible vCPU count\"),\"\\n\",n().createElement(l.li,null,n().createElement(l.code,{display:\"inline\"},\"<MEMORY>\"),\" is the total memory for this instance, in multiples of 256MB and specified in MB units. E.g. \",n().createElement(l.code,{display:\"inline\"},\"5 GB\"),\" of memory is \",n().createElement(l.code,{display:\"inline\"},\"5120\")),\"\\n\"),\"\\n\",n().createElement(l.p,null,\"For example, to specify a worker configuration with \",n().createElement(l.code,{display:\"inline\"},\"8\"),\" CPUs and \",n().createElement(l.code,{display:\"inline\"},\"64GB\"),\" of RAM, the appropriate \",n().createElement(l.code,{display:\"inline\"},\"machineType\"),\" value is:\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{display:\"block\"},\"machineType: 'custom-8-65536'\\n\")),\"\\n\",n().createElement(l.h3,{id:\"local-ssds--scratch-disks\"},\"Local SSDs / Scratch Disks\"),\"\\n\",n().createElement(l.p,null,n().createElement(l.a,{href:\"https://cloud.google.com/compute/docs/disks/local-ssd\"},\"Local SSDs\"),\" are high-performance SSD storage devices attached to the physical machine where your compute instance is running. Because they are attached to the physical host, all data will be lost when the instance shuts off. They are very well-suited for ephemeral workloads that require high I/O.\"),\"\\n\",n().createElement(l.p,null,\"Each attached disk is 375GB in size and is cheaper per-GB than persistent disks.\"),\"\\n\",n().createElement(l.p,null,\"When the instance comes online, the disks will be unformatted and unmounted (i.e. not usable) unless the instance image you select has support for automatically formatting and mounting attached disks. \",n().createElement(l.a,{href:\"https://cloud.google.com/compute/docs/disks/local-ssd#formatindividual\"},\"See here\"),\" for instructions on how to manually do this.\"),\"\\n\",n().createElement(l.h3,{id:\"shielded-vm-configuration--secure-boot\"},\"Shielded VM Configuration / Secure Boot\"),\"\\n\",n().createElement(l.p,null,\"GCP offers three \",n().createElement(l.a,{href:\"https://cloud.google.com/security/shielded-cloud/shielded-vm\"},\"Shielded VM\"),\" features:\"),\"\\n\",n().createElement(l.ul,null,\"\\n\",n().createElement(l.li,null,\"\\n\",n().createElement(l.p,null,\"Secure Boot\"),\"\\n\"),\"\\n\",n().createElement(l.li,null,\"\\n\",n().createElement(l.p,null,\"vTPM (Virtual Trusted Platform Module)\"),\"\\n\"),\"\\n\",n().createElement(l.li,null,\"\\n\",n().createElement(l.p,null,\"Integrity Monitoring\"),\"\\n\"),\"\\n\"),\"\\n\",n().createElement(l.p,null,\"vTPM and Integrity Monitoring are enabled by default. \",n().createElement(l.code,{display:\"inline\"},\"gobld\"),\" allows you to toggle Secure Boot on by setting the boolean \",n().createElement(l.code,{display:\"inline\"},\"enableSecureBoot\"),\" config property.\"),\"\\n\",n().createElement(l.p,null,\"Note that Shielded VM Config can only be set when using an image with a UEFI-compatible disk.\"),\"\\n\",n().createElement(l.p,null,\"Also, Secure Boot does not play nicely with VirtualBox so avoid enabling Secure Boot on instances with VirtualBox installed.\"),\"\\n\",n().createElement(l.h3,{id:\"interface---scsi-vs-nvme\"},\"Interface - SCSI vs NVME\"),\"\\n\",n().createElement(l.p,null,n().createElement(l.a,{href:\"https://cloud.google.com/compute/docs/disks/local-ssd#choose_an_interface\"},\"GCP Documentation\")),\"\\n\",n().createElement(l.p,null,\"The default local SSD interface is NVME. The other option is SCSI.\"),\"\\n\",n().createElement(l.p,null,\"NVME has the highest possible performance, but SCSI has maximum performance for more images (for example, all Windows images). SCSI also requires more configuration in some scenarios and anecdotally \",n().createElement(l.a,{href:\"https://github.com/elastic/infra/issues/7594#issuecomment-529352396\"},\"has more issues\"),\" \",n().createElement(l.a,{href:\"https://github.com/elastic/dev/issues/1176#issuecomment-525373742\"},\"compared to NVME\"),\".\"),\"\\n\",n().createElement(l.p,null,\"If you're not sure which to use, use the default, and switch it if you run into issues.\"),\"\\n\",n().createElement(l.h2,{id:\"kubernetes-provider\"},\"Kubernetes Provider\"),\"\\n\",n().createElement(l.p,null,\"The Kubernetes provider enables launching Buildkite agents in a Kubernetes cluster.\"),\"\\n\",n().createElement(l.p,null,n().createElement(l.strong,null,\"N.B\"),\": Currently our configured GKE node-pools utilise autoscaling with a minimum value of \",n().createElement(l.code,{display:\"inline\"},\"0\"),\".\\nTherefore there might be a short delay to worker startup if there are no available GKE nodes.\"),\"\\n\",n().createElement(l.h2,{id:\"provider-configuration-2\"},\"Provider Configuration\"),\"\\n\",n().createElement(l.p,null,\"The default provider configuration defines fields that can't be changed on a per pod basis.\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{className:\"language-yaml\",display:\"block\"},\"providers:\\n  k8s:\\n    config:\\n      agentTokenSecret: 'buildkite-agent-token' # The Kubernetes secret that contains the Buildkite agent token to map through to the pod env.\\n      imagePullSecrets: 'elastic-prod-registry' # The Kubernetes imagePullSecrets for the image\\n      namespace: 'jenkins-agents'               # The Kubernetes namespace to launch the workers in\\n      nodePoolLabel: 'jenkins-agents'           # Kubernetes node pool selector label\\n      podStartTimeout: 300                      # How long to wait for a pod to enter the `RUNNING` phase\\n\")),\"\\n\",n().createElement(l.h3,{id:\"agent-default-configuration-2\"},\"Agent Default Configuration\"),\"\\n\",n().createElement(l.p,null,'The following configuration is used to specify the \"default\" K8s pod configuration.\\nAll of these fields can be overridden using Agent tags from the Buildkite pipeline.'),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{className:\"language-yaml\",display:\"block\"},\"providers:\\n  k8s:\\n    defaults:\\n      agentImage: '<buildkite-agent-sidecar docker image>' # The agent injector image to use as an init container.\\n      cpu: '1000m'                                         # The CPU resources for the container\\n      ephemeralStorage: '10G'                              # The ephemeral storage resources for the container\\n      injectAgent: true                                    # Should the Buildkite agent be injected into the Kubernetes pod\\n      memory: '1000Mi'                                     # The Memory resources for the container\\n      podAnnotations:                                      # Annotations to apply to the launched pod.\\n        key: value\\n      serviceAccount: ''                                   # Service account to assign to pod\\n\")),\"\\n\",n().createElement(l.h3,{id:\"supported-agent-configuration-tags-2\"},\"Supported agent configuration tags\"),\"\\n\",n().createElement(l.p,null,\"The following agent configuration tags are supported by the Kubernetes provider:\"),\"\\n\",n().createElement(l.table,null,n().createElement(l.thead,null,n().createElement(l.tr,null,n().createElement(l.th,null,\"Tag\"),n().createElement(l.th,null,\"Description\"),n().createElement(l.th,null,\"Type\"),n().createElement(l.th,null,\"Default\"))),n().createElement(l.tbody,null,n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"agentImage\")),n().createElement(l.td,null,\"The agent injector image to use as an init container, the contents of which will be copied to \",n().createElement(l.code,{display:\"inline\"},\"/buildkite/\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"cpu\")),n().createElement(l.td,null,\"Amount of CPU resources to allocate to agent container. Must be a valid Kubernetes resource format.\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"ephemeralStorage\")),n().createElement(l.td,null,\"Amount of ephemeral storage to assign to the agent. The ephemeral storage is provisioned using Local SSDs mounted on the Kubernetes node.\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"image\")),n().createElement(l.td,null,\"Container image to use.\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"None\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"imageUID\")),n().createElement(l.td,null,\"Container UID\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Integer\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"None\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"injectAgent\")),n().createElement(l.td,null,\"Should the Buildkite agent be injected into the container\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Bool\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"instanceMaxAge\")),n().createElement(l.td,null,\"How long can this agent live for in minutes\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Integer\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"memory\")),n().createElement(l.td,null,\"Amount of Memory resources to allocate to the agent container. Must be a valid Kubenetes resource format.\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"serviceAccount\")),n().createElement(l.td,null,\"Kubenetes Service account to mount to the container\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"String\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))),n().createElement(l.tr,null,n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"useVault\")),n().createElement(l.td,null,\"Should a Vault token be generated and injected for this agent?\"),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Bool\")),n().createElement(l.td,null,n().createElement(l.code,{display:\"inline\"},\"Provider default\"))))),\"\\n\",n().createElement(l.h3,{id:\"injecting-the-buildkite-agent\"},\"Injecting the Buildkite Agent\"),\"\\n\",n().createElement(l.p,null,\"Running Buildkite Agent's as Kubernetes pods enables us to leverage the capabilities offered to us by Kubernetes.\\nOne of those capabilities is the option to inject an \",n().createElement(l.code,{display:\"inline\"},\"initContainer\"),\" as part of the Kubernetes pod definition.\"),\"\\n\",n().createElement(l.p,null,\"This \",n().createElement(l.code,{display:\"inline\"},\"initContainer\"),' runs before the \"main\" container, and is used to setup a shared Kubernetes volume which is used to hold\\nthe contents of the ',n().createElement(l.code,{display:\"inline\"},\"agentImage\"),\" filesystem.\"),\"\\n\",n().createElement(l.p,null,\"The benefit of this is that the \",n().createElement(l.code,{display:\"inline\"},\"agentImage\"),\" container can contain the bare-minimum of files required to support operating as a\\nBuildkite-agent, such as the \",n().createElement(l.code,{display:\"inline\"},\"buildkite-agent\"),\" binary and config file, any additional binaries that would be useful like Vault,\\nplus any hooks or plugins that we wish to include by default.\"),\"\\n\",n().createElement(l.p,null,'The shared Kubernetes volume then gets mounted into the \"main\" container as ',n().createElement(l.code,{display:\"inline\"},\"/buildkite-agent\"),\", and the Builkite-agent process\\nis launched from this volume.\"),\"\\n\",n().createElement(l.h3,{id:\"controlling-the-process-uid\"},\"Controlling the Process UID\"),\"\\n\",n().createElement(l.p,null,\"By default, containers are executed as the \",n().createElement(l.code,{display:\"inline\"},\"root\"),\" user with a UID of \",n().createElement(l.code,{display:\"inline\"},\"0\"),\".\"),\"\\n\",n().createElement(l.p,null,\"This ensures the maximum compatability with upstream or Bring-Your-Own (BYO) images that are commonly found on the Docker Hub,\\nsuch as \",n().createElement(l.code,{display:\"inline\"},\"golang\"),\", \",n().createElement(l.code,{display:\"inline\"},\"maven\"),\", etc.\"),\"\\n\",n().createElement(l.p,null,'In some cases it\\'s necessary to ensure that processes are executed under a specific \"non-root\" UID. This could be due to\\napplication requirements, security restrictions etc.',n().createElement(l.br),\"\\n\",\"If this is the case, the \",n().createElement(l.code,{display:\"inline\"},\"imageUID\"),\" agent tag can be specified. This value will then be used to apply a corresponding\\nSecurityContext to the generated pod, thereby ensuring that the process UID and GID are set to the specified value, and any\\nfiles are correctly permissioned into the specified UID.\"),\"\\n\",n().createElement(l.p,null,n().createElement(l.strong,null,\"N.B\"),\": The specified UID needs to exist within the Docker image. Otherwise the Agent is likely to fail to launch.\"),\"\\n\",n().createElement(l.p,null,\"If your \",n().createElement(l.code,{display:\"inline\"},\"Dockerfile\"),\" defines a \",n().createElement(l.code,{display:\"inline\"},\"USER <user>[:<group>]\"),\" instruction, then the \",n().createElement(l.code,{display:\"inline\"},\"UID\"),\" of that user should match the \",n().createElement(l.code,{display:\"inline\"},\"imageUID\"),\" defined in pipeline.\"),\"\\n\",n().createElement(l.p,null,\"The easiest way to identify the correct \",n().createElement(l.code,{display:\"inline\"},\"imageUID\"),\" value is to run the \",n().createElement(l.code,{display:\"inline\"},\"id\"),\" command within the container image being used.\",n().createElement(l.br),\"\\n\",\"For example:\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{className:\"language-shell\",display:\"block\"},\"$ docker run --rm -it golang:1.18 id\\nuid=0(root) gid=0(root) groups=0(root)\\n\")),\"\\n\",n().createElement(l.h2,{id:\"provider-interface\"},\"Provider interface\"),\"\\n\",n().createElement(l.p,null,\"To be a provider in Gobld you will need to implement the \",n().createElement(l.a,{href:\"https://github.com/elastic/gobld/tree/main/models/provider.go\"},n().createElement(l.code,{display:\"inline\"},\"models.Provider\"),\" interface\")),\"\\n\",n().createElement(l.h3,{id:\"configuration-and-initialization\"},\"Configuration and initialization\"),\"\\n\",n().createElement(l.p,null,\"Each provider is responsible for parsing, validating and merging its own configuration. For both the provider configuration and the worker configuration it will be passed a \",n().createElement(l.code,{display:\"inline\"},\"map[string]interface{}\"),\" that can be decoded into an internal configuration struct using \",n().createElement(l.code,{display:\"inline\"},\"mapstructure.Decode\"),\". For an example take a look at the \",n().createElement(l.code,{display:\"inline\"},\"processConfig\"),\" function in the GCP provider.\"),\"\\n\",n().createElement(l.p,null,\"On initialization (\",n().createElement(l.code,{display:\"inline\"},\"func init()\"),\") the provider should register itself with the \",n().createElement(l.code,{display:\"inline\"},\"New()\"),\" function that will load and validate the provider and its configuration. This function will be called as part of the validation Gobld does on PR testing so should catch any configuration issues before they get deployed.\"),\"\\n\",n().createElement(l.h3,{id:\"connect\"},\"Connect\"),\"\\n\",n().createElement(l.p,null,\"This function will actually authenticate and connect the provider on startup. This is separated from \",n().createElement(l.code,{display:\"inline\"},\"New()\"),\" so that we are able to validate configuration separately from actually connecting to the provider.\"),\"\\n\",n().createElement(l.h3,{id:\"create\"},\"Create\"),\"\\n\",n().createElement(l.p,null,\"When Gobld decides to create a worker this is how it asks the provider to create it:\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{display:\"block\"},\"name string              # The name of the worker\\nworkerConfig string      # The worker configuration that Gobld wants the provider to launch\\nseed int64               # A number based off the build ID and amount of retry attempts. This can be used by providers to round robin between different availability zones\\nlabels []string          # A list of extra labels which should be appended to the worker configuration\\nconfig map[string]string # A list of dynamic configuration that has been set via Jenkins labels\\n\")),\"\\n\",n().createElement(l.p,null,\"In this function the provider will generally need to:\"),\"\\n\",n().createElement(l.ul,null,\"\\n\",n().createElement(l.li,null,\"Retrieve the actual configuration for the worker that has been requested\"),\"\\n\",n().createElement(l.li,null,\"Append any extra labels\"),\"\\n\",n().createElement(l.li,null,\"Update the configuration based on the dynamic configuration\"),\"\\n\",n().createElement(l.li,null,\"Optionally calculate which zone to create the instance in based off the \",n().createElement(l.code,{display:\"inline\"},\"seed\")),\"\\n\",n().createElement(l.li,null,\"Supply the to be created instance with its Jenkins swarm configuration (using something like a metadata service, cloud config or similar service for the provider)\"),\"\\n\",n().createElement(l.li,null,\"Create the instance\"),\"\\n\"),\"\\n\",n().createElement(l.h3,{id:\"delete\"},\"Delete\"),\"\\n\",n().createElement(l.p,null,\"Once a worker is no longer needed Gobld will ask for it to be deleted from the provider:\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{display:\"block\"},\"name string      # The name of the worker that should be deleted\\ninstanceMetadata # A mapping of instance metadata that is provided by List(). This can be used as an optimization for providers that need to know which zone and instance is in.\\n\")),\"\\n\",n().createElement(l.h3,{id:\"list\"},\"List\"),\"\\n\",n().createElement(l.p,null,\"Returns a list of all workers in the provider. It is important that this function returns all workers that haven't completed their Gobld lifecycle. I.e. Do not just include a list of \",n().createElement(l.code,{display:\"inline\"},\"running\"),\" workers. As this list will also be used by Gobld to properly cleanup workers that have failed to launch and get into a running state.\"),\"\\n\",n().createElement(l.pre,null,n().createElement(l.code,{display:\"block\"},\"workers []string                   # A list of workers that should match the names given to Create()\\ninstanceMetadata map[string]string # A map that can be used by providers to be able to optimize delete operations (e.g. keeping a mapping of each instance and which zone they are in)\\n\")),\"\\n\",n().createElement(l.h2,{id:\"managing-providers\"},\"Managing providers\"),\"\\n\",n().createElement(l.h2,{id:\"registering-your-provider\"},\"Registering your provider\"),\"\\n\",n().createElement(l.p,null,\"Include your provider in \",n().createElement(l.a,{href:\"https://github.com/elastic/gobld/tree/main/providers/_all/all.go\"},\"providers/_all/all.go\")),\"\\n\",n().createElement(l.h3,{id:\"rate-limiting\"},\"Rate limiting\"),\"\\n\",n().createElement(l.p,null,\"Providers are responsible for implementing their own rate limiting. Gobld prioritizes requesting new instances as fast as possible (by calling Create() async).\"))}}})(),i})()));","frontmatter":{"id":"ciGobldProviders","slug":"/ci/gobld/providers/readme","title":"Providers","summary":"Gobld Providers","date":"2022-03-28T00:00:00.000Z","tags":["ci","ci/cd","developer tools","buildkite","gobld","engineering","platform"],"link":"https://github.com/elastic/ci/blob/main","linkPath":"docs/gobld/providers.mdx"},"missionId":"krVideos"},"__N_SSG":true}