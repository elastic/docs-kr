{"pageProps":{"bundle":"!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"mdxJsReact\"),require(\"React\")):\"function\"==typeof define&&define.amd?define([\"mdxJsReact\",\"React\"],t):\"object\"==typeof exports?exports.MDXContent=t(require(\"mdxJsReact\"),require(\"React\")):e.MDXContent=t(e.mdxJsReact,e.React)}(this,((e,t)=>(()=>{\"use strict\";var n={24:e=>{e.exports=t},825:t=>{t.exports=e}},r={};function l(e){var t=r[e];if(void 0!==t)return t.exports;var a=r[e]={exports:{}};return n[e](a,a.exports,l),a.exports}l.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return l.d(t,{a:t}),t},l.d=(e,t)=>{for(var n in t)l.o(t,n)&&!l.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},l.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),l.r=e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})};var a={};return(()=>{l.r(a),l.d(a,{default:()=>r});var e=l(825),t=l(24),n=l.n(t);const r=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=Object.assign({},(0,e.useMDXComponents)(),t.components),l=r.wrapper;return l?n().createElement(l,t,n().createElement(a)):a();function a(){var r=Object.assign({p:\"p\",strong:\"strong\",img:\"img\",h2:\"h2\",pre:\"pre\",code:\"code\"},(0,e.useMDXComponents)(),t.components),l=r.DocCallOut;return l||o(\"DocCallOut\",!0),n().createElement(n().Fragment,null,n().createElement(r.p,null,\"Elasticsearch 에서는 단일 데이터 단위를 \",n().createElement(r.strong,null,\"도큐먼트(document)\"),\" 라고 하며 이 도큐먼트를 모아놓은 집합을 \",n().createElement(r.strong,null,\"인덱스(Index)\"),\" 라고 합니다. 인덱스라는 단어가 여러 뜻으로 사용되기 때문에 데이터 저장 단위인 인덱스는 \",n().createElement(r.strong,null,\"인디시즈(indices)\"),\" 라고 표현하기도 합니다. 이 책에서는 데이터를 Elasticsearch에 저장하는 행위는 \",n().createElement(r.strong,null,\"색인\"),\", 그리고 도큐먼트의 집합 단위는 \",n().createElement(r.strong,null,\"인덱스\"),\" 라고 하겠습니다.\"),\"\\n\",n().createElement(r.p,null,\"인덱스는 기본적으로 **샤드(shard)**라는 단위로 분리되고 각 노드에 분산되어 저장이 됩니다. 샤드는 루씬의 단일 검색 인스턴스 입니다. 다음은 하나의 인덱스가 5개의 샤드로 저장되도록 설정한 예 입니다.\"),\"\\n\",n().createElement(r.p,null,n().createElement(r.img,{src:\"/ZWxhc3RpYy9kb2NzLWtyL2VzZ3VpZGU3/assets/03-02_index_shard_1.png\",alt:\"인덱스와 샤드\"})),\"\\n\",n().createElement(r.h2,{id:\"프라이머리-샤드primary-shard와-복제본replica\"},\"프라이머리 샤드(Primary Shard)와 복제본(Replica)\"),\"\\n\",n().createElement(r.p,null,\"인덱스를 생성할 때 별도의 설정을 하지 않으면 \",n().createElement(r.strong,null,\"7.0\"),\" 버전부터는 \",n().createElement(r.strong,null,\"디폴트로 1\"),\"개의 샤드로 인덱스가 구성되며 \",n().createElement(r.strong,null,\"6.x\"),\" 이하 버전에서는 \",n().createElement(r.strong,null,\"5개\"),\"로 구성됩니다. 클러스터에 노드를 추가하게 되면 샤드들이 각 노드들로 분산되고 디폴트로 1개의 복제본을 생성합니다. 처음 생성된 샤드를 \",n().createElement(r.strong,null,\"프라이머리 샤드(Primary Shard)\"),\", 복제본은 \",n().createElement(r.strong,null,\"리플리카(Replica)\"),\" 라고 부릅니다. 예를 들어 한 인덱스가 5개의 샤드로 구성어 있고, 클러스터가 4개의 노드로 구성되어 있다고 가정하면 각각 5개의 프라이머리 샤드와 복제본, 총 10개의 샤드들이 전체 노드에 골고루 분배되어 저장됩니다.\"),\"\\n\",n().createElement(r.p,null,n().createElement(r.img,{src:\"/ZWxhc3RpYy9kb2NzLWtyL2VzZ3VpZGU3/assets/03-02_index_shard_2.png\",alt:\"5개의 프라이머리 샤드와 복제본이 4개의 노드에 분산되어 저장된 예\"})),\"\\n\",n().createElement(l,{color:\"danger\"},n().createElement(r.p,null,\"노드가 1개만 있는 경우 프라이머리 샤드만 존재하고 복제본은 생성되지 않습니다. Elasticsearch 는 아무리 작은 클러스터라도 데이터 가용성과 무결성을 위해 최소 \",n().createElement(r.strong,null,\"3개의 노드\"),\"로 구성 할 것을 권장하고 있습니다.\")),\"\\n\",n().createElement(r.p,null,\"같은 샤드와 복제본은 동일한 데이터를 담고 있으며 \",n().createElement(r.strong,null,\"반드시 서로 다른 노드에 저장이 됩니다\"),\". 만약에 위 그림에서 Node-3 노드가 시스템 다운이나 네트워크 단절등으로 사라지면 이 클러스터는 Node-3 에 있던 0번과 4번 샤드들을 유실하게 됩니다. 하지만 아직 다른 노드들 Node-1, Node-2 에 0번, 4번 샤드가 남아있으므로 여전히 전체 데이터는 유실이 없이 사용이 가능합니다.\"),\"\\n\",n().createElement(r.p,null,n().createElement(r.img,{src:\"/ZWxhc3RpYy9kb2NzLWtyL2VzZ3VpZGU3/assets/03-02_index_shard_3.png\",alt:\"Node-3 노드가 유실되어 0번, 4번 샤드가 다른 노드에 복제본을 새로 생성한 예\"})),\"\\n\",n().createElement(r.p,null,\"처음에 클러스터는 먼저 유실된 노드가 복구 되기를 기다립니다. 하지만 타임아웃이 지나 더 유실된 노드가 복구되지 않는다고 판단이 되면 Elasticsearch는 복제본이 사라져 1개만 남은 0번, 4번 샤드들의 복제를 시작합니다. 처음에 4개였던 노드가 3개로 줄어도 복제가 끝나면 0~4번 까지의 프라이머리 샤드, 복제본이 각각 5개씩 총 10개의 데이터로 유지됩니다.\"),\"\\n\",n().createElement(r.p,null,n().createElement(r.img,{src:\"/ZWxhc3RpYy9kb2NzLWtyL2VzZ3VpZGU3/assets/03-02_index_shard_4.png\",alt:\"노드가 3개로 줄었을 때도 전체 데이터 유지\"})),\"\\n\",n().createElement(r.p,null,\"이렇게 프라이머리 샤드와 리플리카를 통해 Elasticsearch는 운영 중에 노드가 유실 되어도 데이터를 잃어버리지 않고 데이터의 가용성과 무결성을 보장합니다.\"),\"\\n\",n().createElement(l,{color:\"warning\"},n().createElement(r.p,null,\"프라이머리 샤드가 유실된 경우에는 새로 프라이머리 샤드가 생성되는 것이 아니라, 남아있던 복제본이 먼저 프라이머리 샤드로 승격이 되고 다른 노드에 새로 복제본을 생성하게 됩니다.\")),\"\\n\",n().createElement(r.h2,{id:\"샤드-개수-설정\"},\"샤드 개수 설정\"),\"\\n\",n().createElement(r.p,null,\"샤드의 개수는 인덱스를 처음 생성할 때 지정할 수 있습니다. 프라이머리 샤드 수는 인덱스를 처음 생성할 때 지정하며, \",n().createElement(r.strong,null,\"인덱스를 재색인 하지 않는 이상 바꿀 수 없습니다\"),\". 복제본의 개수는 나중에 변경이 가능합니다. 아래는 curl 명령을 통해 REST API로 샤드가 5개, 복제본은 1개인 books 라는 이름의 인덱스를 생성하는 예제입니다. REST API에 대해서는 다음 장에서 더 자세히 다루도록 하겠습니다.\"),\"\\n\",n().createElement(r.pre,null,n().createElement(r.code,{className:\"language-bash\",display:\"block\"},'$ curl -XPUT \"http://localhost:9200/books\" -H \\'Content-Type: application/json\\' -d\\'\\n{\\n  \"settings\": {\\n    \"number_of_shards\": 5,\\n    \"number_of_replicas\": 1\\n  }\\n}\\'\\n')),\"\\n\",n().createElement(r.p,null,\"books 인덱스의 복제본 수를 0으로 변경하려면 아래 명령으로 업데이트가 가능합니다.\"),\"\\n\",n().createElement(r.pre,null,n().createElement(r.code,{className:\"language-bash\",display:\"block\"},\"$ curl -XPUT \\\"http://localhost:9200/books/_settings\\\" -H 'Content-Type: application/json' -d'\\n{\\n  \\\"number_of_replicas\\\": 0\\n}'\\n\")),\"\\n\",n().createElement(r.p,null,\"만약에 4개의 노드를 가진 클러스터에 프라이머리 샤드 5개, 복제본 1개인 books 인덱스, 그리고 프라이머리 샤드 3개 복제본 0개인 magazines 인덱스가 있다고 하면 전체 샤드들은 아래와 같은 모양으로 배치될 수 있습니다.\"),\"\\n\",n().createElement(r.p,null,n().createElement(r.img,{src:\"/ZWxhc3RpYy9kb2NzLWtyL2VzZ3VpZGU3/assets/03-02_index_shard_5.png\",alt:\"books 인덱스와 magazines 인덱스\"})))}};function o(e,t){throw new Error(\"Expected \"+(t?\"component\":\"object\")+\" `\"+e+\"` to be defined: you likely forgot to import, pass, or provide it.\")}})(),a})()));","frontmatter":{"id":"esG7-03-02-index-shard","slug":"/krEsguide7/esG7-03-02-index-shard","title":"3.2 인덱스와 샤드 - Index & Shards","description":"모든 문서에 대한 저작권은 Elastic 과 김종민(kimjmin@gmail.com) 에게 있으며 허가되지 않은 무단 복제나 배포 및 출판을 금지합니다. 본 문서의 내용 및 포함된 자료를 인용하고자 하는 경우 출처를 명시하고 게재된 주소를 김종민(kimjmin@gmail.com)에게 알려주시기 바랍니다. date: 2022-01-25","tags":["system","architecture","index","shards"],"link":"https://github.com/elastic/docs-kr/esguide7/blob/main","linkPath":"03-cluster/03-02-index-shard.mdx"},"missionId":"krEsguide7"},"__N_SSG":true}